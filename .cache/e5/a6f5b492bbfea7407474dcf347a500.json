{"id":"../node_modules/react-router/react-router.js","dependencies":[{"name":"/srv/atlas/atlas-web/package.json","includedInParent":true,"mtime":1589460883313},{"name":"/srv/atlas/atlas-web/node_modules/react-router/package.json","includedInParent":true,"mtime":499162500000},{"name":"history","loc":{"line":1,"column":41},"parent":"/srv/atlas/atlas-web/node_modules/react-router/react-router.js","resolved":"/srv/atlas/atlas-web/node_modules/history/history.js"},{"name":"prop-types","loc":{"line":1,"column":72},"parent":"/srv/atlas/atlas-web/node_modules/react-router/react-router.js","resolved":"/srv/atlas/atlas-web/node_modules/prop-types/index.js"},{"name":"react","loc":{"line":1,"column":102},"parent":"/srv/atlas/atlas-web/node_modules/react-router/react-router.js","resolved":"/srv/atlas/atlas-web/node_modules/react/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MemoryRouter = q;\nexports.Navigate = u;\nexports.Outlet = w;\nexports.Route = y;\nexports.Router = r;\nexports.Routes = B;\nexports.createRoutesFromChildren = C;\nexports.generatePath = generatePath;\nexports.matchRoutes = L;\nexports.resolveLocation = F;\nexports.useBlocker = useBlocker;\nexports.useHref = useHref;\nexports.useLocation = E;\nexports.useMatch = useMatch;\nexports.useNavigate = v;\nexports.useOutlet = x;\nexports.useParams = useParams;\nexports.useResolvedLocation = G;\nexports.useRoutes = D;\n\nvar _history = require(\"history\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction h() {\n  h = Object.assign || function (a) {\n    for (var b = 1; b < arguments.length; b++) {\n      var c = arguments[b],\n          d;\n\n      for (d in c) Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n    }\n\n    return a;\n  };\n\n  return h.apply(this, arguments);\n}\n\nvar k = \"production\" !== \"development\" ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction l(a, b) {\n  if (!a) throw Error(b);\n}\n\nfunction m(a, b) {\n  if (!a) {\n    \"undefined\" !== typeof console && console.warn(b);\n\n    try {\n      throw Error(b);\n    } catch (c) {}\n  }\n}\n\nvar n = _react.default.createContext(null);\n\n\"production\" !== \"development\" && (n.displayName = \"Location\");\n\nvar p = _react.default.createContext({\n  outlet: null,\n  params: k({}),\n  pathname: \"\",\n  route: null\n});\n\n\"production\" !== \"development\" && (p.displayName = \"Route\");\n\nfunction q(a) {\n  var b = a.children,\n      c = a.initialEntries,\n      d = a.initialIndex;\n  a = a.timeout;\n\n  var e = _react.default.useRef(null);\n\n  null == e.current && (e.current = (0, _history.createMemoryHistory)({\n    initialEntries: c,\n    initialIndex: d\n  }));\n  return _react.default.createElement(r, {\n    children: b,\n    history: e.current,\n    timeout: a\n  });\n}\n\n\"production\" !== \"development\" && (q.displayName = \"MemoryRouter\", q.propTypes = {\n  children: _propTypes.default.node,\n  timeout: _propTypes.default.number,\n  initialEntries: _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.shape({\n    pathname: _propTypes.default.string,\n    search: _propTypes.default.string,\n    hash: _propTypes.default.string,\n    state: _propTypes.default.object,\n    key: _propTypes.default.string\n  })])),\n  initialIndex: _propTypes.default.number\n});\n\nfunction u(a) {\n  var b = a.to,\n      c = a.replace,\n      d = a.state,\n      e = v();\n  a = _react.default.useContext(n);\n  null == a ? \"production\" !== \"development\" ? l(!1, \"<Navigate> may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  \"production\" !== \"development\" ? m(!a.history.static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.\") : void 0;\n\n  _react.default.useEffect(function () {\n    e(b, {\n      replace: c,\n      state: d\n    });\n  });\n\n  return null;\n}\n\n\"production\" !== \"development\" && (u.displayName = \"Navigate\", u.propTypes = {\n  to: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.shape({\n    pathname: _propTypes.default.string,\n    search: _propTypes.default.string,\n    hash: _propTypes.default.string\n  })]).isRequired,\n  replace: _propTypes.default.bool,\n  state: _propTypes.default.object\n});\n\nfunction w() {\n  return x();\n}\n\n\"production\" !== \"development\" && (w.displayName = \"Outlet\", w.propTypes = {});\n\nfunction y(a) {\n  a = a.element;\n  return void 0 === a ? _react.default.createElement(w, null) : a;\n}\n\n\"production\" !== \"development\" && (y.displayName = \"Route\", y.propTypes = {\n  children: _propTypes.default.node,\n  element: _propTypes.default.element,\n  path: _propTypes.default.string\n});\n\nfunction z(a) {\n  return a();\n}\n\nvar A = _react.default.useTransition || function () {\n  return [z, !1];\n};\n\nfunction r(a) {\n  var b = a.children;\n  b = void 0 === b ? null : b;\n  var c = a.history;\n  a = a.timeout;\n\n  var d = void 0 === a ? 2E3 : a,\n      e = _react.default.useState(c.location);\n\n  a = e[0];\n  var f = e[1];\n  d = A({\n    timeoutMs: d\n  });\n  var g = d[0];\n  d = d[1];\n  e = _react.default.useRef(!0);\n  _react.default.useContext(n) ? \"production\" !== \"development\" ? l(!1, \"You cannot render a <Router> inside another <Router>. You never need more than one.\") : l(!1) : void 0;\n  e.current && (e.current = !1, c.listen(function (a) {\n    var b = a.location;\n    g(function () {\n      f(b);\n    });\n  }));\n  return _react.default.createElement(n.Provider, {\n    children: b,\n    value: {\n      history: c,\n      location: a,\n      pending: d\n    }\n  });\n}\n\n\"production\" !== \"development\" && (r.displayName = \"Router\", r.propTypes = {\n  children: _propTypes.default.node,\n  history: _propTypes.default.shape({\n    action: _propTypes.default.string,\n    location: _propTypes.default.object,\n    push: _propTypes.default.func,\n    replace: _propTypes.default.func,\n    go: _propTypes.default.func,\n    listen: _propTypes.default.func,\n    block: _propTypes.default.func\n  }),\n  timeout: _propTypes.default.number\n});\n\nfunction B(a) {\n  var b = a.basename;\n  b = void 0 === b ? \"\" : b;\n  var c = a.caseSensitive;\n  c = void 0 === c ? !1 : c;\n  a = C(a.children);\n  return D(a, b, c);\n}\n\n\"production\" !== \"development\" && (B.displayName = \"Routes\", B.propTypes = {\n  basename: _propTypes.default.string,\n  caseSensitive: _propTypes.default.bool,\n  children: _propTypes.default.node\n});\n\nfunction C(a) {\n  var b = [];\n\n  _react.default.Children.forEach(a, function (a) {\n    if (_react.default.isValidElement(a)) {\n      var c = a.props,\n          e = c.children;\n      c = c.path;\n      c = void 0 === c ? \"/\" : c;\n      a.type === _react.default.Fragment ? b.push.apply(b, C(e)) : (a = {\n        path: c,\n        element: a\n      }, e = C(e), e.length && (a.children = e), b.push(a));\n    }\n  });\n\n  return b;\n}\n\nfunction E() {\n  return _react.default.useContext(n).location;\n}\n\nfunction v() {\n  var a = _react.default.useContext(p).pathname,\n      b = _react.default.useContext(n);\n\n  null == b ? \"production\" !== \"development\" ? l(!1, \"useNavigate() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n\n  var c = b.history,\n      d = b.pending,\n      e = _react.default.useRef(!1);\n\n  _react.default.useEffect(function () {\n    e.current = !0;\n  });\n\n  return _react.default.useCallback(function (b, g) {\n    var f = void 0 === g ? {} : g;\n    g = f.replace;\n    f = f.state;\n    e.current ? \"number\" === typeof b ? c.go(b) : (b = F(b, a), c[g || d ? \"replace\" : \"push\"](b, f)) : \"production\" !== \"development\" ? m(!1, \"You should call navigate() in a useEffect, not when your component is first rendered.\") : void 0;\n  }, [c, a, d]);\n}\n\nfunction x() {\n  return _react.default.useContext(p).outlet;\n}\n\nfunction G(a) {\n  var b = _react.default.useContext(p).pathname;\n\n  return _react.default.useMemo(function () {\n    return F(a, b);\n  }, [a, b]);\n}\n\nvar I, J;\n\"production\" !== \"development\" && (I = {}, J = function (a, b, c) {\n  b || I[a] || (I[a] = !0, \"production\" !== \"development\" ? m(!1, c) : void 0);\n});\n\nfunction D(a, b, c) {\n  void 0 === b && (b = \"\");\n  void 0 === c && (c = !1);\n\n  var d = _react.default.useContext(p),\n      e = d.params,\n      f = d.pathname;\n\n  d = d.route;\n\n  if (J) {\n    var g = d && d.path;\n    J(f, !d || d.path.endsWith(\"*\"), 'You rendered descendant <Routes> (or called `useRoutes`) at \"' + f + '\" (under <Route path=\"' + (g + '\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won\\'t match anymore and therefore the child routes will never render.\\n\\nPlease change the parent <Route path=\"') + (g + '\"> to <Route path=\"' + g + '/*\">.'));\n  }\n\n  b = b ? K([f, b]) : f;\n  var t = E();\n  return (f = _react.default.useMemo(function () {\n    return L(a, t, b, c);\n  }, [a, t, b, c])) ? f.reduceRight(function (a, c) {\n    var d = c.pathname,\n        f = c.route;\n    return _react.default.createElement(p.Provider, {\n      children: f.element,\n      value: {\n        outlet: a,\n        params: k(h({}, e, {}, c.params)),\n        pathname: K([b, d]),\n        route: f\n      }\n    });\n  }, null) : null;\n}\n\nfunction L(a, b, c, d) {\n  function e(a) {\n    a = g[a];\n    var b = a[1];\n    if (M(a[0], !0, d)[0].test(f)) return {\n      v: b.map(function (a, c) {\n        c = b.slice(0, c + 1);\n        c = K(c.map(function (a) {\n          return a.path;\n        }));\n        var e = M(c, !1, d);\n        c = e[1];\n        e = f.match(e[0]);\n        var g = \"/\" + e[1],\n            t = e.slice(2);\n        return {\n          params: c.reduce(function (a, b, c) {\n            c = t[c];\n\n            try {\n              var d = decodeURIComponent(c.replace(/\\+/g, \" \"));\n            } catch (Q) {\n              \"production\" !== \"development\" ? m(!1, 'The value for the URL param \"' + b + '\" will not be decoded because the string \"' + (c + '\" is a malformed URL segment. This is probably due to a bad percent encoding (the error message was: ') + (Q.message + \").\")) : void 0, d = c;\n            }\n\n            a[b] = d;\n            return a;\n          }, {}),\n          pathname: g,\n          route: a\n        };\n      })\n    };\n  }\n\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = !1);\n  \"string\" === typeof b && (b = (0, _history.parsePath)(b));\n  c = c.replace(/^\\/+|\\/+$/g, \"\");\n  var f = b.pathname.slice(1);\n  if (c) if (c === f) f = \"\";else if (f.startsWith(c)) f = f.slice(c.length).replace(/^\\/+/, \"\");else return null;\n  var g = N(a);\n  O(g);\n\n  for (a = 0; a < g.length; ++a) if (b = e(a), \"object\" === typeof b) return b.v;\n\n  return null;\n}\n\nfunction N(a, b, c, d, e) {\n  void 0 === b && (b = []);\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = []);\n  void 0 === e && (e = []);\n  a.forEach(function (a, g) {\n    var f = K([c, a.path]),\n        H = d.concat(a);\n    g = e.concat(g);\n    b.push([f, H, g]);\n    a.children && N(a.children, b, f, H, g);\n  });\n  return b;\n}\n\nvar P = /^:\\w+$/,\n    R = 2,\n    S = 1,\n    T = 10,\n    U = -2;\n\nfunction V(a) {\n  return \"*\" === a;\n}\n\nfunction W(a) {\n  a = a.split(\"/\");\n  var b = a.length;\n  a.some(V) && (b += U);\n  return a.filter(function (a) {\n    return !V(a);\n  }).reduce(function (a, b) {\n    return a + (P.test(b) ? R : \"\" === b ? S : T);\n  }, b);\n}\n\nfunction O(a) {\n  var b = a.reduce(function (a, b) {\n    b = b[0];\n    a[b] = W(b);\n    return a;\n  }, {});\n  a.sort(function (a, d) {\n    var c = a[2];\n    a = b[a[0]];\n    var f = d[2];\n    d = b[d[0]];\n    return a !== d ? d - a : X(c, f);\n  });\n}\n\nfunction X(a, b) {\n  return a.length === b.length && a.slice(0, -1).every(function (a, d) {\n    return a === b[d];\n  }) ? a[a.length - 1] - b[b.length - 1] : 0;\n}\n\nfunction M(a, b, c) {\n  var d = [],\n      e = \"^(\" + a.replace(/^\\/+/, \"\").replace(/\\*\\//g, \"\").replace(/\\/?\\*?$/, \"\").replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\").replace(/:(\\w+)/g, function (a, b) {\n    d.push(b);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  a.endsWith(\"*\") ? (a.endsWith(\"/*\") && (e += \"\\\\/?\"), d.push(\"*\"), e += \"(.*)\") : b && (e += \"\\\\/?\");\n  b && (e += \"$\");\n  return [new RegExp(e, c ? void 0 : \"i\"), d];\n}\n\nfunction K(a) {\n  return a.join(\"/\").replace(/\\/\\/+/g, \"/\");\n}\n\nfunction Y(a, b) {\n  var c = b.replace(/\\/+$/, \"\").replace(/\\/\\/+/g, \"/\").split(\"/\");\n  a.replace(/\\/\\/+/g, \"/\").split(\"/\").forEach(function (a) {\n    \"..\" === a ? 1 < c.length && c.pop() : \".\" !== a && c.push(a);\n  });\n  return 1 < c.length ? K(c) : \"/\";\n}\n\nfunction F(a, b) {\n  void 0 === b && (b = \"/\");\n  var c = \"string\" === typeof a ? (0, _history.parsePath)(a) : a;\n  a = c.pathname;\n  var d = c.search;\n  d = void 0 === d ? \"\" : d;\n  c = c.hash;\n  c = void 0 === c ? \"\" : c;\n  return {\n    pathname: a ? a.startsWith(\"/\") ? Y(a, \"/\") : Y(a, b) : b,\n    search: d,\n    hash: c\n  };\n}\n\nfunction generatePath(a, b) {\n  void 0 === b && (b = {});\n  return a.replace(/:(\\w+)/g, function (a, d) {\n    return b[d] || \":\" + d;\n  }).replace(/\\*$/, function (a) {\n    return b[a] || a;\n  });\n}\n\n;\n\nfunction useBlocker(a, b) {\n  void 0 === b && (b = !0);\n\n  var c = _react.default.useContext(n);\n\n  null == c ? \"production\" !== \"development\" ? l(!1, \"useBlocker() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  var d = c.history;\n\n  _react.default.useEffect(function () {\n    if (b) {\n      var c = d.block(function (b) {\n        var d = h({}, b, {\n          retry: function () {\n            c();\n            b.retry();\n          }\n        });\n        a(d);\n      });\n      return c;\n    }\n  }, [d, b, a]);\n}\n\n;\n\nfunction useHref(a) {\n  a = G(a);\n\n  var b = _react.default.useContext(n);\n\n  null == b ? \"production\" !== \"development\" ? l(!1, \"useHref() may be used only in the context of a <Router> component.\") : l(!1) : void 0;\n  return b.history.createHref(a);\n}\n\n;\n\nfunction useMatch(a) {\n  var b = E();\n  a = G(a);\n  return b.pathname === a.pathname;\n}\n\n;\n\nfunction useParams() {\n  return _react.default.useContext(p).params;\n}\n\n;"},"sourceMaps":null,"error":null,"hash":"6cb16b29ca442e296cc0e04bb5b7e8ba","cacheData":{"env":{"NODE_ENV":"development"}}}